<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Margeur Pro — Calculateur marges & agrandissements 24×36 (margeur 4 lames)</title>
<link rel="manifest" href="manifest.webmanifest?v=6.9.1">
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js?v=6.9.1'));
<body>
  <div class="container">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
      <h1>Margeur Pro — calculateur marges & agrandissements 24×36 (margeur 4 lames)</h1>
      <div class="toolbar">
        <span id="testTools" class="test-tools">
          <select id="presetSelect">
            <option value="">Tests rapides…</option>
            <optgroup label="Classiques">
              <option value="p_24x30paysage_1">24×30.5 Paysage — 1 cm</option>
              <option value="p_24x30portrait_1.5">24×30.5 Portrait — 1.5 cm</option>
              <option value="p_203x254_paysage_1">20.3×25.4 Paysage — 1 cm</option>
              <option value="p_216x279_paysage_2">21.6×27.9 Paysage — 2 cm</option>
              <option value="p_254x254_paysage_1">25.4×25.4 Carré — 1 cm</option>
            </optgroup>
            <optgroup label="Grand format">
              <option value="p_305x406_paysage_0.8">30.5×40.6 Paysage — 0.8 cm</option>
              <option value="p_406x508_paysage_2.5">40.6×50.8 Paysage — 2.5 cm</option>
              <option value="p_305x406_portrait_2">30.5×40.6 Portrait — 2 cm</option>
            </optgroup>
            <optgroup label="Marges fines (0.5 cm)">
              <option value="p_24x30_paysage_0.5">24×30.5 Paysage — 0.5 cm</option>
              <option value="p_203x254_paysage_0.5">20.3×25.4 Paysage — 0.5 cm</option>
              <option value="p_216x279_paysage_0.5">21.6×27.9 Paysage — 0.5 cm</option>
            </optgroup>
            <optgroup label="Marges larges (3.5 cm)">
              <option value="p_24x30_paysage_3.5">24×30.5 Paysage — 3.5 cm</option>
              <option value="p_305x406_paysage_3.5">30.5×40.6 Paysage — 3.5 cm</option>
              <option value="p_406x508_paysage_3.5">40.6×50.8 Paysage — 3.5 cm</option>
            </optgroup>
            <optgroup label="Tirages contact">
              <option value="c_127x178_equal_0.5">5×7&quot; (12.7×17.8) — Bordures identiques 0.5 cm</option>
              <option value="c_203x254_equal_0.5">8×10&quot; (20.3×25.4) — Bordures identiques 0.5 cm</option>
              <option value="c_216x279_equal_0.8">8.5×11&quot; (21.6×27.9) — Bordures identiques 0.8 cm</option>
            </optgroup>
            <optgroup label="Contraintes">
              <option value="e_equalBorders_1.5">Bordures identiques — 1.5 cm</option>
              <option value="f_forceW_20">Forcer largeur 20 cm</option>
              <option value="f_forceH_18">Forcer hauteur 18 cm</option>
              <option value="f_forceW_28">Forcer largeur 28 cm (grand papier)</option>
            </optgroup>
          </select>
          <button id="applyPreset" class="primary">Appliquer</button>
          <button id="randomBtn" class="primary" title="Génère un cas réaliste aléatoire">Cas aléatoire</button>
        </span>
        <button id="aboutBtn" class="primary">À propos</button>
        <span class="pill">v1.1.0</span>
      </div>
    </div>

    <div class="card section grid grid-4">
      <div>
        <label>Format papier (hauteur × largeur, cm)</label>
        <select id="paper">
          <option data-h="8.9"  data-w="12.7">8.9 × 12.7 cm</option>
          <option data-h="8.9"  data-w="14.0">8.9 × 14 cm</option>
          <option data-h="9.96" data-w="12.5">9.96 × 12.5 cm</option>
          <option data-h="10.5" data-w="14.8">10.5 × 14.8 cm</option>
          <option data-h="10.0" data-w="15.0">10 × 15 cm</option>
          <option data-h="12.7" data-w="17.8">12.7 × 17.8 cm</option>
          <option data-h="16.5" data-w="21.6">16.5 × 21.6 cm</option>
          <option data-h="17.8" data-w="24.0">17.8 × 24 cm</option>
          <option data-h="20.3" data-w="25.4">20.3 × 25.4 cm</option>
          <option data-h="21.0" data-w="29.7">21 × 29.7 cm</option>
          <option data-h="21.6" data-w="27.9">21.6 × 27.9 cm</option>
          <option data-h="24.0" data-w="30.5" selected>24 × 30.5 cm</option>
          <option data-h="25.4" data-w="25.4">25.4 × 25.4 cm</option>
          <option data-h="27.9" data-w="35.6">27.9 × 35.6 cm</option>
          <option data-h="30.5" data-w="40.6">30.5 × 40.6 cm</option>
          <option data-h="40.6" data-w="50.8">40.6 × 50.8 cm</option>
          <option data-h="50.8" data-w="61.0">50.8 × 61 cm</option>
        </select>
        <div class="muted" id="paperInfo">Hauteur × Largeur : 24 × 30.5 cm</div>
        <div class="row" style="margin-top:8px">
          <label class="inline"><input type="checkbox" id="useCustom"> Utiliser un format personnalisé</label>
        </div>
        <div id="customWrap" class="row muted" style="margin-top:6px">
          <span>H</span><input id="custH" type="number" step="0.01" min="1" value="24" style="width:90px">
          <span>× W</span><input id="custW" type="number" step="0.01" min="1" value="30.5" style="width:90px">
        </div>
      </div>

      <div>
        <label>Orientation de l’image (négatif 24×36)</label>
        <div class="radio-row">
          <label class="row" style="font-weight:500">
            <input type="radio" name="orient" value="landscape" checked>
            Paysage (36 mm horizontal)
          </label>
          <label class="row" style="font-weight:500">
            <input type="radio" name="orient" value="portrait">
            Portrait (36 mm vertical)
          </label>
        </div>
        <div class="hint">Rapport W/H du négatif : 3/2 (paysage) • 2/3 (portrait).</div>
      </div>

      <div>
        <label>Marge minimale (cm) — margeur <b>4 lames</b></label>
        <div class="row">
          <input id="marginRange" class="slider" type="range" min="0" max="5" step="0.1" value="1.0">
          <input id="marginInput" type="number" min="0" step="0.1" value="1.0" style="width:90px">
        </div>
        <div class="muted">En mode « Préserver 2:3 », l’appli choisit automatiquement si la marge minimale se place sur <b>Haut/Bas</b> ou <b>Gauche/Droite</b> pour maximiser la taille.</div>
      </div>

      <div>
        <label>Mode & Contrainte</label>
        <div class="radio-row" id="modeRow">
          <label class="row" style="font-weight:500">
            <input type="radio" name="mode" value="ratio" checked>
            Préserver 2:3 (marge minimale, image centrée)
          </label>
          <label class="row" style="font-weight:500">
            <input type="radio" name="mode" value="equalBorders">
            Bordures identiques (recadrage si nécessaire)
          </label>
        </div>
        <div id="forceWrap">
          <div class="muted" style="margin-top:6px">Contrainte (uniquement en mode « Préserver 2:3 »)</div>
          <div class="row" style="margin-top:6px">
            <label class="inline"><input type="radio" name="force" value="none" checked> Aucune</label>
            <label class="inline"><input type="radio" name="force" value="width"> Forcer <b>largeur image</b> (cm)</label>
            <input id="forceW" type="number" min="0" step="0.1" value="20" style="width:90px">
          </div>
          <div class="row" style="margin-top:6px">
            <label class="inline"><input type="radio" name="force" value="height"> Forcer <b>hauteur image</b> (cm)</label>
            <input id="forceH" type="number" min="0" step="0.1" value="15" style="width:90px">
          </div>
          <div id="forceNote" class="warn" style="display:none"></div>
        </div>
      </div>
    </div>

    <div class="card section">
      <div style="display:flex;align-items:center;gap:8px;justify-content:space-between;">
        <h3 style="margin:0;font-size:18px">Aperçu proportionnel</h3>
        <div id="minBannerTop">🟦 Marge minimale sur : <b id="minBannerSide">—</b></div>
      </div>
      <div class="grid grid-2" style="margin-top:12px">
        <div>
          <div class="box">
            <div class="canvas-wrap">
              <div id="paperBox" class="canvas-inner"></div>
            </div>
            <div class="legend"><span><span class="dot"></span> Valeurs à régler sur le <b>margeur 4 lames</b></span></div>
          </div>
        </div>
        <div class="result">
          <h3 style="margin:0 0 8px 0;font-size:18px">Résultats</h3>
          <div id="results"></div>
        </div>
      </div>
    </div>
</script>
<style>
  :root { --bg:#fafafa; --fg:#111; --muted:#6b7280; --card:#fff; --border:#e5e7eb; --accent:#2563eb; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
  h1{font-size:22px;margin:0}
  .container{max-width:1100px;margin:0 auto;padding:20px}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;box-shadow:0 1px 2px rgba(0,0,0,.03);}
  .section{padding:16px 18px}
  .grid{display:grid;gap:16px}
  @media(min-width:1100px){ .grid-4{grid-template-columns:1.1fr 1fr 1fr 1.2fr} .grid-2{grid-template-columns:1fr 1fr} }
  label{font-weight:600;font-size:13px;display:block;margin-bottom:6px}
  select,input[type=number]{width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:10px;background:white}
  .muted{color:var(--muted);font-size:12px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .slider{width:100%}
  input[type=range]{width:100%}
  .radio-row{display:flex;gap:14px;align-items:center;flex-wrap:wrap}
  .pill{display:inline-flex;gap:6px;align-items:center;background:#eef2ff;border:1px solid #dbeafe;border-radius:999px;padding:3px 10px;font-size:12px}
  .result ul{margin:0;padding-left:18px}
  .box{border:1px solid var(--border);border-radius:14px;background:#f8fafc;padding:10px}
  .canvas-wrap{position:relative;width:100%;background:white;border:1px solid var(--border);border-radius:12px;overflow:hidden}
  .canvas-inner{position:relative;width:100%;min-height:160px;}
  .img-rect{background:#d1d5db;border-radius:6px;width:100%;height:100%}
  .footer-note{font-size:12px;color:var(--muted)}
  .hint{font-size:11px;color:#6b7280}
  .inline{display:inline-flex;gap:8px;align-items:center}
  .disabled{opacity:.55;pointer-events:none;filter:grayscale(0.2)}
  .warn{color:#b45309;font-size:12px;margin-top:6px}
  .badge{position:absolute;transform:translate(-50%,-50%);background:rgba(17,24,39,.85);color:#fff;font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.2);white-space:nowrap;pointer-events:none}
  .legend{display:flex;gap:8px;align-items:center;margin-top:8px}
  .legend span{display:inline-flex;align-items:center;gap:6px;font-size:12px;color:#374151}
  .dot{width:8px;height:8px;border-radius:50%;display:inline-block;background:#374151}
  button.primary{background:#2563eb;color:#fff;border:none;padding:6px 12px;border-radius:8px;font-size:13px;cursor:pointer}
  #minBannerTop{display:none;margin-left:auto;background:rgba(17,24,39,.85);color:#fff;padding:6px 10px;border-radius:10px;font-size:12px;border:1px solid rgba(255,255,255,.15)}
  .toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .test-tools{display:none}
</style>
</head>
  <!-- === Margeur Pro : affichage photo taquets (paysage) — intégré v1.2 === -->
<div class="card section" id="taquetsCard" style="margin-top:14px">
  <div style="display:flex;align-items:center;gap:10px;justify-content:space-between;flex-wrap:wrap">
    <h3 style="margin:0;font-size:18px">Photo de taquets</h3>
    <label class="row" style="font-weight:500">
      <input type="checkbox" id="toggleTaquetPhoto" checked>
      Margeur Dunco (afficher/masquer)
    </label>
  </div>
  <div id="taquetPhotoBox" class="box" style="display:none;margin-top:10px">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
      <strong id="taquetPhotoTitle">Repères taquets — —</strong>
      <span id="taquetPhotoFile" class="muted"></span>
    </div>
    <img id="taquetPhotoImg" alt="Repères taquets (paysage)" style="max-width:50%;height:auto;border-radius:8px;border:1px solid var(--border)">
  </div>
</div>
<script>
(function(){
  const DIR = "taquets/";                           // dossier en minuscule
  const EXT = ["jpeg","jpg","png","webp"];
  const $ = s => document.querySelector(s);

  const box    = $("#taquetPhotoBox");
  const img    = $("#taquetPhotoImg");
  const title  = $("#taquetPhotoTitle");
  const fileUi = $("#taquetPhotoFile");
  const toggle = $("#toggleTaquetPhoto");

  // Utilise ta fonction existante getPaper() – elle renvoie des cm
  function getPaperSizeMm(){
    try {
      if (typeof getPaper === "function") {
        const p = getPaper(); // {w: cm, h: cm}
        if (p && p.w > 0 && p.h > 0) {
          const W = Math.round(Number(p.w) * 10); // cm -> mm
          const H = Math.round(Number(p.h) * 10);
          return {W,H};
        }
      }
    } catch(e){}
    return {W:240, H:305}; // fallback
  }

  // Essaie W×H et H×W
  function buildCandidates(W, H){
    const stems = [
      `Taquets_${W}x${H}_paysage`,
      `Taquets_${H}x${W}_paysage`
    ];
    const files = [];
    for (const stem of stems){
      for (const ext of EXT){
        files.push(`${DIR}${stem}.${ext}`);
      }
    }
    return files;
  }

  function tryLoad(urls, onOK, onFail){
    if (!urls.length){ onFail(); return; }
    const u = urls.shift();
    const t = new Image();
    t.onload  = () => onOK(u);
    t.onerror = () => tryLoad(urls, onOK, onFail);
    t.src = u + "?v=" + Date.now(); // anti-cache
  }

  function updateTaquetPhoto(){
    if(!toggle || !box){ return; }
    if(!toggle.checked){
      box.style.display = "none";
      return;
    }
    const {W,H} = getPaperSizeMm();
    title.textContent = `Repères taquets — ${W} × ${H} mm (paysage)`;

    const candidates = buildCandidates(W,H);
    tryLoad(candidates.slice(),
      (urlFound)=>{
        img.src = urlFound;
        fileUi.textContent = "";   // ← on ne montre plus le nom
        box.style.display = "";
      },
      ()=>{
        img.removeAttribute("src");
        fileUi.textContent = "";
        box.style.display = "none";
      }
    );
  }

  // Intégration à ta logique existante
  if (typeof window.compute === "function") {
    const _orig = window.compute;
    window.compute = function(){
      const r = _orig.apply(this, arguments);
      try { updateTaquetPhoto(); } catch(e){}
      return r;
    };
  }

  document.addEventListener("change", (e)=>{
    if (e.target && (e.target.tagName === "SELECT" || e.target.tagName === "INPUT")){
      updateTaquetPhoto();
    }
  });

  document.addEventListener("DOMContentLoaded", updateTaquetPhoto);
})();
</script>
  
    <div style="margin-top:14px" class="footer-note">
      © Margeur Pro — négatif 24×36 mm (ratio 2:3). Conçu pour un <b>margeur 4 lames</b>. Vérifiez visuellement au margeur avant tirage.
      • Mode 2:3 = marges ≥ minimale (côté choisi automatiquement) ; • Bordures identiques = marges fixées (recadrage possible).
    </div>
  </div>

<!-- Modal À propos -->
<div id="aboutModal" style="position:fixed;inset:0;background:rgba(0,0,0,.5);display:none;align-items:center;justify-content:center;z-index:999;">
  <div style="background:white;border-radius:14px;max-width:460px;width:92%;padding:20px;box-shadow:0 4px 10px rgba(0,0,0,.2);">
    <h2 style="margin-top:0;font-size:20px;">À propos de Margeur Pro</h2>
    <p style="font-size:14px;line-height:1.5;">
      <b>Margeur Pro</b> est un outil gratuit pour calculer et visualiser les marges d’agrandissements 24×36 mm sur papiers standards, <b>spécifique aux margeurs 4 lames</b>.
    </p>
    <p style="font-size:13px;color:#555;">
      Version : <b>1.1.0</b><br>
      Auteur : A. Reichling<br>
      Licence : Utilisation libre (non commerciale)<br>
      Source : <a href="https://github.com/alainreichling/margeur-pro" target="_blank" rel="noopener">GitHub</a>
    </p>
    <div class="muted" style="font-size:12px;margin:6px 0 12px 0;">
      Astuce : ajoutez <code>?tests=on</code> à l’URL pour afficher les « Tests rapides » (ex. <code>.../index.html?tests=on</code>).
    </div>
    <div style="display:flex;justify-content:space-between;gap:10px;margin-top:6px;flex-wrap:wrap;">
      <button id="aboutClose" class="primary">Fermer</button>
      <button id="purgeBtn" class="primary" title="Désinstaller le service worker et vider le cache">Purger le cache</button>
    </div>
  </div>
</div>

<script>
const ASPECTS = {
  landscape: { aspect: 3/2, negH: 2.4 },
  portrait:  { aspect: 2/3, negH: 3.6 },
};

function q(sel){ return document.querySelector(sel); }
function round2(x){ return Math.round(x*100)/100; }

// Show test tools only if ?tests=on is present
(function(){
  const params = new URLSearchParams(window.location.search);
  const show = params.get('tests') === 'on';
  const el = document.getElementById('testTools');
  if(el){ el.style.display = show ? 'inline-flex' : 'none'; }
})();

function getPaper(){
  const useCustom = q("#useCustom").checked;
  if(useCustom){
    const H = parseFloat(q("#custH").value || "0") || 0;
    const W = parseFloat(q("#custW").value || "0") || 0;
    return { label: "Personnalisé", h: H, w: W };
  }
  const opt = q("#paper").selectedOptions[0];
  return { label: opt.textContent, h: parseFloat(opt.dataset.h), w: parseFloat(opt.dataset.w) };
}

function setPaperByHW(h, w){
  const options = Array.from(q("#paper").options);
  const idx = options.findIndex(o => Math.abs(parseFloat(o.dataset.h) - h) < 1e-6 && Math.abs(parseFloat(o.dataset.w) - w) < 1e-6);
  if(idx >= 0){
    q("#useCustom").checked = false;
    q("#paper").selectedIndex = idx;
  } else {
    q("#useCustom").checked = true;
    q("#custH").value = String(h);
    q("#custW").value = String(w);
  }
  const evt = new Event('change');
  q("#paper").dispatchEvent(evt);
}

function updateForceMax(){
  const paper = getPaper();
  const margin = parseFloat(q("#marginInput").value || "0") || 0;
  const H_in = Math.max(0, paper.h - 2*margin);
  const W_in = Math.max(0, paper.w - 2*margin);
  const fw = q("#forceW");
  const fh = q("#forceH");
  if(fw){ fw.max = String(Math.max(0, round2(W_in))); fw.placeholder = `≤ ${round2(W_in)} cm`; }
  if(fh){ fh.max = String(Math.max(0, round2(H_in))); fh.placeholder = `≤ ${round2(H_in)} cm`; }
}

function sideFromMargins(mTB, mLR, margin){
  const eps = 1e-6;
  const tbHit = Math.abs(mTB - margin) < eps;
  const lrHit = Math.abs(mLR - margin) < eps;
  if(tbHit && !lrHit) return "TB";
  if(lrHit && !tbHit) return "LR";
  return (mTB <= mLR) ? "TB" : "LR";
}

function bestFitForMinMargin(paper, margin, ASPECT){
  function fitWithTBmin(){
    let H = paper.h - 2*margin;
    let W = H * ASPECT;
    if(W > paper.w - 2*margin){ W = paper.w - 2*margin; H = W / ASPECT; }
    return {imgH:H, imgW:W, mTB:(paper.h - H)/2, mLR:(paper.w - W)/2, minOn:"TB"};
  }
  function fitWithLRmin(){
    let W = paper.w - 2*margin;
    let H = W / ASPECT;
    if(H > paper.h - 2*margin){ H = paper.h - 2*margin; W = H * ASPECT; }
    return {imgH:H, imgW:W, mTB:(paper.h - H)/2, mLR:(paper.w - W)/2, minOn:"LR"};
  }
  const A = fitWithTBmin();
  const B = fitWithLRmin();
  const areaA = A.imgH * A.imgW;
  const areaB = B.imgH * B.imgW;
  if(areaA > areaB + 1e-9) return A;
  if(areaB > areaA + 1e-9) return B;
  const hitA = Math.abs(A.mTB - margin) < 1e-6 || Math.abs(A.mLR - margin) < 1e-6;
  const hitB = Math.abs(B.mTB - margin) < 1e-6 || Math.abs(B.mLR - margin) < 1e-6;
  if(hitA && !hitB) return A;
  if(hitB && !hitA) return B;
  return A;
}

function compute(){
  const paper = getPaper();
  const margin = parseFloat(q("#marginInput").value || "0") || 0;
  const mode = document.querySelector('input[name="mode"]:checked').value;
  const orient = document.querySelector('input[name="orient"]:checked').value;
  const { aspect: ASPECT, negH: NEG_H_CM } = ASPECTS[orient];

  q("#paperInfo").textContent = `Hauteur × Largeur : ${round2(paper.h)} × ${round2(paper.w)} cm`;

  const forceWrap = q("#forceWrap");
  const forceNote = q("#forceNote");
  if(mode === "ratio"){ forceWrap.classList.remove("disabled"); } else { forceWrap.classList.add("disabled"); }
  if(forceNote){ forceNote.style.display = "none"; forceNote.textContent = ""; }

  const bannerTop = q("#minBannerTop");
  const bannerSide = q("#minBannerSide");
  const hideBanner = () => { if(bannerTop) bannerTop.style.display = 'none'; };

  let html = "";
  let preview = { mTB:0, mLR:0 };

  if(paper.h <= 0 || paper.w <= 0){
    q("#results").innerHTML = `<div class="muted">Entrez un format papier personnalisé valide (H et W &gt; 0).</div>`;
    hideBanner();
    renderPreview({h:10,w:15}, {mTB:0,mLR:0}, "ratio", 0);
    return;
  }

  if(mode === "ratio"){
    const H_in = paper.h - 2*margin;
    const W_in = paper.w - 2*margin;
    if(H_in <= 0 || W_in <= 0){
      html = `<div class="muted">Marge trop grande pour ce format de papier.</div>`;
      hideBanner();
    } else {
      const forceMode = document.querySelector('input[name="force"]:checked').value;
      let imgH, imgW, mTB, mLR, chosenMinSide;

      if(forceMode === "none"){
        const best = bestFitForMinMargin(paper, margin, ASPECT);
        imgH = best.imgH; imgW = best.imgW; mTB = best.mTB; mLR = best.mLR;
        chosenMinSide = sideFromMargins(mTB, mLR, margin);
      } else if(forceMode === "width"){
        let targetW = parseFloat(q("#forceW").value || "0") || 0;
        const maxW = W_in;
        if(targetW > maxW){ targetW = maxW; if(forceNote){ forceNote.style.display = "block"; forceNote.textContent = `⚠️ Largeur forcée limitée à ${round2(maxW)} cm.`; } q("#forceW").value = String(round2(maxW)); }
        if(targetW <= 0){ html = `<div class="muted">Entrez une largeur d’image valide.</div>`; hideBanner(); q("#results").innerHTML = html; renderPreview(paper,{mTB:0,mLR:0},mode,margin); return; }
        imgW = targetW; imgH = imgW / ASPECT;
        if(imgH > H_in){ imgH = H_in; imgW = imgH * ASPECT; }
        mTB = (paper.h - imgH)/2; mLR = (paper.w - imgW)/2;
        chosenMinSide = sideFromMargins(mTB, mLR, margin);
      } else { // force height
        let targetH = parseFloat(q("#forceH").value || "0") || 0;
        const maxH = H_in;
        if(targetH > maxH){ targetH = maxH; if(forceNote){ forceNote.style.display = "block"; forceNote.textContent = `⚠️ Hauteur forcée limitée à ${round2(maxH)} cm.`; } q("#forceH").value = String(round2(maxH)); }
        if(targetH <= 0){ html = `<div class="muted">Entrez une hauteur d’image valide.</div>`; hideBanner(); q("#results").innerHTML = html; renderPreview(paper,{mTB:0,mLR:0},mode,margin); return; }
        imgH = targetH; imgW = imgH * ASPECT;
        if(imgW > W_in){ imgW = W_in; imgH = imgW / ASPECT; }
        mTB = (paper.h - imgH)/2; mLR = (paper.w - imgW)/2;
        chosenMinSide = sideFromMargins(mTB, mLR, margin);
      }

      const factor = imgH / NEG_H_CM;
      const allOK = (mTB + 1e-9 >= margin) && (mLR + 1e-9 >= margin);

      html = `<ul>
        <li>🧭 Orientation image : <b>${orient === "portrait" ? "Portrait" : "Paysage"}</b> — <i>margeur 4 lames</i></li>
        <li>📸 <b>Taille image</b> : ${round2(imgH)} × ${round2(imgW)} cm (H × L)</li>
        <li>📏 <b>Facteur d’agrandissement</b> : ${round2(factor)}×</li>
        <li>🎯 <b>Marge minimale appliquée sur</b> : <b>${chosenMinSide==="TB"?"Haut/Bas":"Gauche/Droite"}</b></li>
        <li>⬆️⬇️ <b>Marge haut/bas</b> : ${round2(mTB)} cm</li>
        <li>⬅️➡️ <b>Marge gauche/droite</b> : ${round2(mLR)} cm</li>
        <li>${allOK ? "✅" : "⚠️"} Rapport 2:3 conservé, image centrée, <b>marges ≥ minimale</b>.</li>
      </ul>`;

      const bannerTop = q("#minBannerTop");
      const bannerSide = q("#minBannerSide");
      if(bannerTop && bannerSide){
        bannerSide.textContent = (chosenMinSide === "TB") ? "Haut/Bas" : "Gauche/Droite";
        bannerTop.style.display = "inline-block";
      }

      renderPreview(paper, {mTB, mLR}, "ratio", margin);
      q("#results").innerHTML = html;
      return;
    }
  } else {
    const Hwin = paper.h - 2*margin;
    const Wwin = paper.w - 2*margin;
    if(Hwin <= 0 || Wwin <= 0){
      html = `<div class="muted">Marge trop grande pour ce format de papier.</div>`;
      const bannerTop = q("#minBannerTop"); if(bannerTop) bannerTop.style.display = "none";
    } else {
      const ASPECT = ASPECTS[orient].aspect;
      const NEG_H_CM2 = ASPECTS[orient].negH;
      const winAspect = Wwin / Hwin;
      let cropOn = "aucun";
      let negH_vis = NEG_H_CM2;
      let negW_vis = NEG_H_CM2 * ASPECT;
      if(Math.abs(winAspect - ASPECT) > 1e-9){
        if(winAspect > ASPECT){ cropOn = "hauteur"; negH_vis = negW_vis / winAspect; }
        else { cropOn = "largeur"; negW_vis = negH_vis * winAspect; }
      }
      const factor = Hwin / negH_vis;
      const cropH_total_mm = Math.max(0, (NEG_H_CM2 - negH_vis)*10);
      const cropW_total_mm = Math.max(0, (NEG_H_CM2*ASPECT - negW_vis)*10);
      const cropEachH_mm = cropH_total_mm/2;
      const cropEachW_mm = cropW_total_mm/2;

      html = `<ul>
        <li>🧭 Orientation image : <b>${orient === "portrait" ? "Portrait" : "Paysage"}</b> — <i>margeur 4 lames</i></li>
        <li>📸 <b>Taille image</b> : ${round2(Hwin)} × ${round2(Wwin)} cm (fenêtre utile)</li>
        <li>📏 <b>Facteur d’agrandissement</b> : ${round2(factor)}×</li>
        <li>🟦 <b>Bordures identiques</b> : ${round2(margin)} cm (4 côtés)</li>
        <li>✂️ <b>Recadrage du négatif</b> : ${
          cropOn==="aucun" ? "—" : (cropOn==="hauteur"
            ? `≈ ${round2(cropEachH_mm)} mm en haut & en bas`
            : `≈ ${round2(cropEachW_mm)} mm à gauche & à droite`)}</li>
        <li>ℹ️ Mode « Bordures identiques » — conçu pour <b>margeur 4 lames</b>.</li>
      </ul>`;

      const bannerTop = q("#minBannerTop"); if(bannerTop) bannerTop.style.display = "none";
      renderPreview(paper, {mTB:margin, mLR:margin}, "equal", margin);
      q("#results").innerHTML = html;
      return;
    }
  }

  q("#results").innerHTML = html;
  renderPreview(paper, {mTB:0,mLR:0}, "ratio", margin);
}

function addBadge(container, text, leftPct, topPct){
  const b = document.createElement("div");
  b.className = "badge";
  b.style.left = leftPct + "%";
  b.style.top = topPct + "%";
  b.textContent = text;
  container.appendChild(b);
}

function renderPreview(paper, prev, mode, margin){
  const box = q("#paperBox");
  box.innerHTML = "";

  box.style.position = "relative";
  box.style.width = "100%";
  if ("aspectRatio" in document.body.style) {
    box.style.aspectRatio = paper.w + " / " + paper.h;
  } else {
    box.style.paddingTop = (paper.h / paper.w) * 100 + "%";
  }

  const inner = document.createElement("div");
  inner.style.position = "absolute";
  inner.style.top = "0";
  inner.style.left = "0";
  inner.style.right = "0";
  inner.style.bottom = "0";

  let pt, pb, pl, pr;
  let mTB, mLR;
  if(mode === "ratio"){
    pt = (prev.mTB / paper.h) * 100;
    pb = (prev.mTB / paper.h) * 100;
    pl = (prev.mLR / paper.w) * 100;
    pr = (prev.mLR / paper.w) * 100;
    mTB = prev.mTB; mLR = prev.mLR;
  } else {
    pt = pb = (margin / paper.h) * 100;
    pl = pr = (margin / paper.w) * 100;
    mTB = margin; mLR = margin;
  }
  inner.style.paddingTop = pt + "%";
  inner.style.paddingBottom = pb + "%";
  inner.style.paddingLeft = pl + "%";
  inner.style.paddingRight = pr + "%";

  const img = document.createElement("div");
  img.className = "img-rect";
  inner.appendChild(img);
  box.appendChild(inner);

  const minOffset = 2;
  const topY = Math.max(pt/2, minOffset);
  const botY = Math.min(100 - pb/2, 100 - minOffset);

  const bias = 12;
  const leftX_raw = pl/2 + bias;
  const rightX_raw = 100 - pr/2 - bias;
  const leftX  = Math.max(12, Math.min(45, leftX_raw));
  const rightX = Math.max(55, Math.min(88, rightX_raw));

  addBadge(box, `Haut: ${round2(mTB)} cm`, 50, topY);
  addBadge(box, `Bas: ${round2(mTB)} cm`, 50, botY);
  addBadge(box, `Gauche: ${round2(mLR)} cm`, leftX, 50);
  addBadge(box, `Droite: ${round2(mLR)} cm`, rightX, 50);
}

async function purgeCaches(){
  try {
    if ('caches' in window) {
      const keys = await caches.keys();
      await Promise.all(keys.map(k => caches.delete(k)));
    }
    if ('serviceWorker' in navigator) {
      const regs = await navigator.serviceWorker.getRegistrations();
      await Promise.all(regs.map(r => r.unregister()));
    }
  } catch(e){}
  const u = new URL(window.location.href);
  u.searchParams.set('nocache', Date.now().toString());
  window.location.replace(u.toString());
}

function applyPresetById(id){
  let H=24, W=30.5, orient='landscape', mode='ratio', margin=1.0, force='none', fW=20, fH=15;
  switch(id){
    case 'p_24x30paysage_1': H=24; W=30.5; orient='landscape'; mode='ratio'; margin=1.0; break;
    case 'p_24x30portrait_1.5': H=24; W=30.5; orient='portrait'; mode='ratio'; margin=1.5; break;
    case 'p_203x254_paysage_1': H=20.3; W=25.4; orient='landscape'; mode='ratio'; margin=1.0; break;
    case 'p_216x279_paysage_2': H=21.6; W=27.9; orient='landscape'; mode='ratio'; margin=2.0; break;
    case 'p_254x254_paysage_1': H=25.4; W=25.4; orient='landscape'; mode='ratio'; margin=1.0; break;
    case 'p_305x406_paysage_0.8': H=30.5; W=40.6; orient='landscape'; mode='ratio'; margin=0.8; break;
    case 'p_406x508_paysage_2.5': H=40.6; W=50.8; orient='landscape'; mode='ratio'; margin=2.5; break;
    case 'p_305x406_portrait_2': H=30.5; W=40.6; orient='portrait'; mode='ratio'; margin=2.0; break;
    case 'p_24x30_paysage_0.5': H=24; W=30.5; orient='landscape'; mode='ratio'; margin=0.5; break;
    case 'p_203x254_paysage_0.5': H=20.3; W=25.4; orient='landscape'; mode='ratio'; margin=0.5; break;
    case 'p_216x279_paysage_0.5': H=21.6; W=27.9; orient='landscape'; mode='ratio'; margin=0.5; break;
    case 'p_24x30_paysage_3.5': H=24; W=30.5; orient='landscape'; mode='ratio'; margin=3.5; break;
    case 'p_305x406_paysage_3.5': H=30.5; W=40.6; orient='landscape'; mode='ratio'; margin=3.5; break;
    case 'p_406x508_paysage_3.5': H=40.6; W=50.8; orient='landscape'; mode='ratio'; margin=3.5; break;
    case 'c_127x178_equal_0.5': H=12.7; W=17.8; orient='landscape'; mode='equalBorders'; margin=0.5; break;
    case 'c_203x254_equal_0.5': H=20.3; W=25.4; orient='landscape'; mode='equalBorders'; margin=0.5; break;
    case 'c_216x279_equal_0.8': H=21.6; W=27.9; orient='landscape'; mode='equalBorders'; margin=0.8; break;
    case 'e_equalBorders_1.5': H=24; W=30.5; orient='landscape'; mode='equalBorders'; margin=1.5; break;
    case 'f_forceW_20': H=24; W=30.5; orient='landscape'; mode='ratio'; margin=1.0; force='width'; fW=20; break;
    case 'f_forceH_18': H=24; W=30.5; orient='portrait'; mode='ratio'; margin=1.0; force='height'; fH=18; break;
    case 'f_forceW_28': H=30.5; W=40.6; orient='landscape'; mode='ratio'; margin=1.0; force='width'; fW=28; break;
    default: return;
  }
  setPaperByHW(H, W);
  document.querySelector(`input[name="orient"][value="${orient}"]`).checked = true;
  document.querySelector(`input[name="mode"][value="${mode}"]`).checked = true;
  q("#marginRange").value = String(margin);
  q("#marginInput").value = String(margin);
  q("#forceW").value = String(fW);
  q("#forceH").value = String(fH);
  document.querySelector(`input[name="force"][value="${force}"]`).checked = true;
  updateForceMax();
  compute();
}

function applyRandomCase(){
  const opts = Array.from(q("#paper").options).map(o => ({h:parseFloat(o.dataset.h), w:parseFloat(o.dataset.w)}));
  const {h,w} = opts[Math.floor(Math.random()*opts.length)];
  setPaperByHW(h,w);
  const orient = Math.random() < 0.5 ? 'landscape' : 'portrait';
  document.querySelector(`input[name="orient"][value="${orient}"]`).checked = true;
  const mode = Math.random() < 0.7 ? 'ratio' : 'equalBorders';
  document.querySelector(`input[name="mode"][value="${mode}"]`).checked = true;
  const margin = Math.round((0.3 + Math.random()*3.2)*10)/10;
  q("#marginRange").value = String(margin);
  q("#marginInput").value = String(margin);
  const r = Math.random();
  if(mode==='ratio' && r < 0.4){
    const forceKind = Math.random() < 0.5 ? 'width' : 'height';
    document.querySelector(`input[name="force"][value="${forceKind}"]`).checked = true;
    const H_in = Math.max(0, h - 2*margin);
    const W_in = Math.max(0, w - 2*margin);
    if(forceKind==='width'){
      const maxW = Math.max(0, W_in);
      const val = Math.max(0.1, Math.min(maxW, Math.round((0.4*maxW + Math.random()*0.6*maxW)*10)/10));
      q("#forceW").value = String(val);
    } else {
      const val = Math.max(0.1, Math.round((0.4*H_in + Math.random()*0.6*H_in)*10)/10);
      q("#forceH").value = String(val);
    }
  } else {
    document.querySelector(`input[name="force"][value="none"]`).checked = true;
  }
  updateForceMax();
  compute();
}

function bind(){
  q("#paper").addEventListener("change", ()=>{
    const opt = q("#paper").selectedOptions[0];
    q("#paperInfo").textContent = `Hauteur × Largeur : ${opt.dataset.h} × ${opt.dataset.w} cm`;
    updateForceMax();
    compute();
  });

  const customWrap = q("#customWrap");
  function applyCustomState(){ customWrap.style.opacity = q("#useCustom").checked ? "1" : ".5"; }
  q("#useCustom").addEventListener("change", ()=>{ applyCustomState(); updateForceMax(); compute(); });
  ["custH","custW"].forEach(id=> q("#"+id).addEventListener("input", ()=>{ updateForceMax(); compute(); }));
  applyCustomState();

  ["marginRange","marginInput"].forEach(id=>{
    q("#"+id).addEventListener("input", (e)=>{
      if(id==="marginRange"){ q("#marginInput").value = e.target.value; } 
      else { q("#marginRange").value = e.target.value; }
      updateForceMax();
      compute();
    });
  });
  document.querySelectorAll('input[name="mode"]').forEach(r=> r.addEventListener("change", compute));
  document.querySelectorAll('input[name="orient"]').forEach(r=> r.addEventListener("change", compute));
  ["forceW","forceH"].forEach(id=> q("#"+id).addEventListener("input", compute));
  document.querySelectorAll('input[name="force"]').forEach(r=> r.addEventListener("change", compute));

  const aboutModal = document.getElementById('aboutModal');
  const aboutBtn = document.getElementById('aboutBtn');
  const aboutClose = document.getElementById('aboutClose');
  const purgeBtn = document.getElementById('purgeBtn');
  if (aboutBtn && aboutModal && aboutClose) {
    aboutBtn.addEventListener('click', ()=> aboutModal.style.display = 'flex');
    aboutClose.addEventListener('click', ()=> aboutModal.style.display = 'none');
    aboutModal.addEventListener('click', (e)=>{ if(e.target === aboutModal) aboutModal.style.display = 'none'; });
  }
  if(purgeBtn){ purgeBtn.addEventListener('click', purgeCaches); }

  const applyBtn = document.getElementById('applyPreset');
  const select = document.getElementById('presetSelect');
  if(applyBtn && select){
    applyBtn.addEventListener('click', ()=> applyPresetById(select.value));
    select.addEventListener('change', ()=> applyPresetById(select.value));
  }
  const randomBtn = document.getElementById('randomBtn');
  if(randomBtn){
    randomBtn.addEventListener('click', applyRandomCase);
  }

  // Toggle tests tools
  (function(){
    const params = new URLSearchParams(window.location.search);
    const show = params.get('tests') === 'on';
    const el = document.getElementById('testTools');
    if(el){ el.style.display = show ? 'inline-flex' : 'none'; }
  })();

  updateForceMax();
  compute();
}

bind();
</script>
<script>
(function(){
  // Si ton dossier est "Taquets/", mets "Taquets/" ici :
  const DIR = "taquets/";   // <-- mets précisément le nom de TON dossier
  const EXT = ["jpeg","jpg","png","webp"];
  const $ = s => document.querySelector(s);

  // ... (le reste du script inchangé)

  // Remplacer ENTIEREMENT la fonction candidatePaths par celle-ci :
  function candidatePaths(W, H){
    // IMPORTANT : on respecte l'ordre EXACT W x H tel que renvoyé par l'app
    // (pas de tri grand/petit)
    const stem = `Taquets_${W}x${H}_paysage`;
    return EXT.map(ext => `${DIR}${stem}.${ext}`);
  }

  // ... (le reste du script inchangé)
})();
</script>
</body>
</html>
